. Indexes & Constraints: The Database Guardrails
A. Uniqueness & Existence (Data Integrity)

// First, create the constraint
CREATE CONSTRAINT unique_emp_id FOR (e:Employee) REQUIRE e.empId IS UNIQUE;

// Now, try to run this twice:
CREATE (:Employee {empId: 'E-101', name: 'Alice'});
CREATE (:Employee {empId: 'E-101', name: 'Bob'}); 
// Result: Neo4j throws an error: "Node(0) already exists with label `Employee` and property `empId` = 'E-101'"


Full-Text Indexes (Fuzzy Search)
Standard indexes only find exact matches. Full-text indexes allow for "search-engine" style queries.

Demonstration:

Cypher
// 1. Create the index on the 'bio' property
CREATE FULLTEXT INDEX bio_search FOR (e:Employee) ON EACH ["bio"];

// 2. Add some data
CREATE (:Employee {name: 'Alice', bio: 'Expert Java developer with Spring Boot experience'});

// 3. Search for "Spring" or "Java" even if only part of the word is known
CALL db.index.fulltext.queryNodes("bio_search", "Spring~") YIELD node, score
RETURN node.name, node.bio, score;


2. Query Profiling: Spotting the "Bottlenecks"
Explain that DB Hits are the currency of Neo4j. More hits = Slower query.

Example 1: The "Unoptimized" Query (AllNodesScan)
Run this before creating a range index on age.

Cypher
PROFILE 
MATCH (e:Employee) 
WHERE e.age > 30 
RETURN e.name;
What to show trainees: In the result graph, look at the top box. It will say AllNodesScan. This means Neo4j had to look at every single employee node in the DB to find those over 30.

Example 2: The "Optimized" Query (IndexSeek)
Cypher
// Create the range index
CREATE INDEX emp_age_idx FOR (e:Employee) ON (e.age);

// Run the profile again
PROFILE 
MATCH (e:Employee) 
WHERE e.age > 30 
RETURN e.name;


Concept,Command to Demo,What it Proves
Constraint,CREATE CONSTRAINT...,"Prevents ""dirty data"" from entering the graph."
Full-Text,db.index.fulltext.queryNodes,Enables Google-like search inside the DB.
EXPLAIN,EXPLAIN MATCH...,"Shows the ""Plan"" without cost (Safety check)."
PROFILE,PROFILE MATCH...,"Shows the ""Cost"" in DB Hits (Performance check)."
Eager Ops,PROFILE MATCH (n) SET n.prop = 'val',Shows when Neo4j is forced to pull all data into memory at once.


The Demo Setup: "The Chaos Database"


Run this script first. It creates data without any constraints or indexes.

Cypher
// Create 1000 'dummy' employees for scaling simulation
UNWIND range(1, 1000) AS id
CREATE (:Employee {empId: 'E-' + id, name: 'Employee ' + id, age: toInteger(rand() * 40 + 20), bio: 'Experienced developer in Java and Spring'});

// Create one specific person we want to find
CREATE (:Employee {empId: 'E-9999', name: 'Expert X', age: 45, bio: 'Specialist in Neo4j Graph Databases'});



. Demo: The Failure of Integrity (Constraints)
The Problem: Without constraints, we can accidentally create the same employee twice, leading to "Data Pollution."

Action: Try to create the same ID again.

Cypher
CREATE (:Employee {empId: 'E-9999', name: 'Duplicate X'});
The Lesson: Neo4j allows this by default! Now we have two "E-9999" nodes.


The Fix:

Cypher
// Clean up duplicates first
MATCH (e:Employee {empId: 'E-9999'}) DETACH DELETE e;

// Enforce the rule
CREATE CONSTRAINT emp_unique_id FOR (e:Employee) REQUIRE e.empId IS UNIQUE;



To give your trainees a "complete" demonstration, we will simulate a real-world performance crisis. We will create a "messy" database, prove why itâ€™s slow using Profiling, and then fix it using Indexes, Constraints, and Memory tuning.

ðŸ—ï¸ The Demo Setup: "The Chaos Database"
Run this script first. It creates data without any constraints or indexes.

Cypher
// Create 1000 'dummy' employees for scaling simulation
UNWIND range(1, 1000) AS id
CREATE (:Employee {empId: 'E-' + id, name: 'Employee ' + id, age: toInteger(rand() * 40 + 20), bio: 'Experienced developer in Java and Spring'});

// Create one specific person we want to find
CREATE (:Employee {empId: 'E-9999', name: 'Expert X', age: 45, bio: 'Specialist in Neo4j Graph Databases'});
1. Demo: The Failure of Integrity (Constraints)
The Problem: Without constraints, we can accidentally create the same employee twice, leading to "Data Pollution."

Action: Try to create the same ID again.

Cypher
CREATE (:Employee {empId: 'E-9999', name: 'Duplicate X'});
The Lesson: Neo4j allows this by default! Now we have two "E-9999" nodes.

The Fix:

Cypher
// Clean up duplicates first
MATCH (e:Employee {empId: 'E-9999'}) DETACH DELETE e;

// Enforce the rule
CREATE CONSTRAINT emp_unique_id FOR (e:Employee) REQUIRE e.empId IS UNIQUE;
2. Demo: The "Slow" Search (Profiling & Range Indexes)
The Problem: Searching for employees by age.

Action: Profile a range search.

Cypher
PROFILE 
MATCH (e:Employee) 
WHERE e.age > 40 
RETURN e.name;
What to show: Point to the "AllNodesScan" operator and the "db hits" count (it will be equal to or greater than the total number of nodes).

The Fix:

Cypher
CREATE INDEX emp_age_index FOR (e:Employee) ON (e.age);
The Result: Re-run the PROFILE. Show the "NodeIndexSeek" operator. The DB hits will drop from 1000+ to just the number of people who actually match the age.



Advanced Search (Full-Text Indexes)
The Problem: Finding someone whose bio contains "Graph" using standard CONTAINS is slow because it can't use a standard index.

The Fix:

Cypher
// 1. Create Full-text index
CREATE FULLTEXT INDEX bio_search FOR (e:Employee) ON EACH ["bio"];

// 2. Search using the index
CALL db.index.fulltext.queryNodes("bio_search", "Graph") YIELD node, score
RETURN node.name, node.bio, score;
The Lesson: Explain that this uses Lucene under the hood, allowing for "fuzzy" matches (e.g., searching for "Graphs~" will still find "Graph").



ðŸ—ï¸ The Demo Setup: "The Chaos Database"
Run this script first. It creates data without any constraints or indexes.

Cypher
// Create 1000 'dummy' employees for scaling simulation
UNWIND range(1, 1000) AS id
CREATE (:Employee {empId: 'E-' + id, name: 'Employee ' + id, age: toInteger(rand() * 40 + 20), bio: 'Experienced developer in Java and Spring'});

// Create one specific person we want to find
CREATE (:Employee {empId: 'E-9999', name: 'Expert X', age: 45, bio: 'Specialist in Neo4j Graph Databases'});
1. Demo: The Failure of Integrity (Constraints)
The Problem: Without constraints, we can accidentally create the same employee twice, leading to "Data Pollution."

Action: Try to create the same ID again.

Cypher
CREATE (:Employee {empId: 'E-9999', name: 'Duplicate X'});
The Lesson: Neo4j allows this by default! Now we have two "E-9999" nodes.

The Fix:

Cypher
// Clean up duplicates first
MATCH (e:Employee {empId: 'E-9999'}) DETACH DELETE e;

// Enforce the rule
CREATE CONSTRAINT emp_unique_id FOR (e:Employee) REQUIRE e.empId IS UNIQUE;
2. Demo: The "Slow" Search (Profiling & Range Indexes)
The Problem: Searching for employees by age.

Action: Profile a range search.

Cypher
PROFILE 
MATCH (e:Employee) 
WHERE e.age > 40 
RETURN e.name;
What to show: Point to the "AllNodesScan" operator and the "db hits" count (it will be equal to or greater than the total number of nodes).

The Fix:

Cypher
CREATE INDEX emp_age_index FOR (e:Employee) ON (e.age);
The Result: Re-run the PROFILE. Show the "NodeIndexSeek" operator. The DB hits will drop from 1000+ to just the number of people who actually match the age.

3. Demo: Advanced Search (Full-Text Indexes)
The Problem: Finding someone whose bio contains "Graph" using standard CONTAINS is slow because it can't use a standard index.

The Fix:

Cypher
// 1. Create Full-text index
CREATE FULLTEXT INDEX bio_search FOR (e:Employee) ON EACH ["bio"];

// 2. Search using the index
CALL db.index.fulltext.queryNodes("bio_search", "Graph") YIELD node, score
RETURN node.name, node.bio, score;
The Lesson: Explain that this uses Lucene under the hood, allowing for "fuzzy" matches (e.g., searching for "Graphs~" will still find "Graph").

4. Demo: Identifying "The Cartesian Product" (The Bottleneck)
The Problem: A query that tries to find two different things but forgets to connect them.

Action: Run this "Bad Query":

Cypher
PROFILE
MATCH (e:Employee {empId: 'E-1'}), (s:Skill {name: 'Java'})
RETURN e, s
What to show: A giant warning in the Neo4j Browser: "This query builds a Cartesian product." * The Explanation: Because there is no relationship defined between e and s, Neo4j is trying to cross-multiply every 'E-1' with every 'Java' skill. In a large DB, this will crash the JVM Heap.



When you have duplicate nodes (nodes with the same business ID but different internal IDs), you need a strategy to decide which one to keep. Usually, you want to keep the "oldest" node (the original) or the "most complete" node (the one with the most relationships).

In Neo4j, every node has a unique internal identity accessible via the function elementId() (or id() in older versions). We use this to differentiate between nodes that look identical.

Here are the three most common strategies for your training:

Strategy 1: Keep the "Original" (Lowest Internal ID)
This is the standard approach. You group nodes by their duplicate property (e.g., empId), sort them by their internal ID, and delete all except the first one.

Cypher
MATCH (e:Employee)
WITH e.empId AS id, collect(e) AS nodes
WHERE size(nodes) > 1
// Keep the first node, get the rest (from index 1 to the end)
UNWIND nodes[1..] AS toDelete
DETACH DELETE toDelete
Strategy 2: Keep the "Most Connected" Node
In a graph, the "value" of a node is often its relationships. You don't want to delete the node that is already connected to 50 projects.

Cypher
MATCH (e:Employee)
// Count how many relationships each duplicate has
WITH e.empId AS id, e, count { (e)--() } AS relCount
ORDER BY id, relCount DESC
// For each ID, keep the one with the highest relCount
WITH id, collect(e) AS nodes
WHERE size(nodes) > 1
UNWIND nodes[1..] AS toDelete
DETACH DELETE toDelete
Strategy 3: The "Merge & Purge" (Data Consolidation)
Sometimes duplicates occur because different properties were added to different nodes. Before deleting, you might want to move properties or relationships to the "survivor."

The APOC way (Easiest): If you have APOC installed, there is a dedicated procedure that merges properties and redirects all relationships to a single "master" node before deleting the duplicates.

Cypher
MATCH (e:Employee {empId: 'E-101'})
WITH collect(e) AS nodes
CALL apoc.refactor.mergeNodes(nodes, {properties: "combine", mergeRels: true})
YIELD node
RETURN node
combine: If Node A has email and Node B has phone, the survivor gets both.

mergeRels: If both nodes were connected to the same Project, they become one relationship.