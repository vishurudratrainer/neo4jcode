 docker run --name neo4j-instance -p 7474:7474 -p 7687:7687 -d  -v C:\neo4j\data:/data -v C:\neo4j\logs:/logs -v C:\neo4j\import:/var/lib/neo4j/import -v C:\neo4j\plugins:/plugins --env NEO4J_AUTH=neo4j/your_chosen_password neo4j:latest

docker run -d --name neo4j-apoc -p 7474:7474 -p 7687:7687 -e NEO4J_AUTH=neo4j/password -e NEO4J_PLUGINS="[\"apoc\", \"apoc-extended\"]" -e NEO4J_dbms_security_procedures_unrestricted=apoc.* neo4j:latest

docker run --name neo4j-instance -p 7474:7474 -p 7687:7687 -d -v C:\neo4j\data:/data -v C:\neo4j\logs:/logs -v C:\neo4j\import:/var/lib/neo4j/import -v C:\neo4j\plugins:/plugins --env NEO4J_AUTH=neo4j/your_chosen_password --env NEO4J_PLUGINS="[\"apoc\", \"apoc-extended\", \"graph-data-science\"]" --env NEO4J_dbms_security_procedures_unrestricted=apoc.*,gds.* --env NEO4J_dbms_security_procedures_allowlist=apoc.*,gds.* neo4j:latest
MAC
docker run --name neo4j-instance \
  -p 7474:7474 -p 7687:7687 \
  -d \
  -v $HOME/neo4j/data:/data \
  -v $HOME/neo4j/logs:/logs \
  -v $HOME/neo4j/import:/var/lib/neo4j/import \
  -v $HOME/neo4j/plugins:/plugins \
  --env NEO4J_AUTH=neo4j/your_chosen_password \
  --env NEO4J_PLUGINS='["apoc", "apoc-extended", "graph-data-science"]' \
  --env NEO4J_dbms_security_procedures_unrestricted=apoc.*,gds.* \
  --env NEO4J_dbms_security_procedures_allowlist=apoc.*,gds.* \
  neo4j:latest
ubuntu
docker run --name neo4j-instance \
  -p 7474:7474 -p 7687:7687 \
  -d \
  -v $HOME/neo4j/data:/data \
  -v $HOME/neo4j/logs:/logs \
  -v $HOME/neo4j/import:/var/lib/neo4j/import \
  -v $HOME/neo4j/plugins:/plugins \
  --env NEO4J_AUTH=neo4j/your_chosen_password \
  --env NEO4J_PLUGINS='["apoc", "apoc-extended", "graph-data-science"]' \
  --env NEO4J_dbms_security_procedures_unrestricted=apoc.*,gds.* \
  --env NEO4J_dbms_security_procedures_allowlist=apoc.*,gds.* \
  neo4j:latest


CALL apoc.load.json("https://jsonplaceholder.typicode.com/todos/") YIELD value
RETURN value.userId, value.id, value.title LIMIT 5


CALL apoc.periodic.iterate(
  "CALL apoc.load.json('https://jsonplaceholder.typicode.com/todos') YIELD value RETURN value",
  "MERGE (t:Todo {id: value.id}) 
   SET t.title = value.title, 
       t.completed = value.completed, 
       t.userId = value.userId",
  {batchSize: 100, parallel: true}
)

CALL apoc.periodic.iterate(
  "CALL apoc.load.json('https://jsonplaceholder.typicode.com/todos') YIELD value RETURN value",
  "MERGE (t:Todo {id: value.id}) SET t.title = value.title",
  {batchSize: 100}
) 
YIELD batches, total, errorMessages
RETURN batches, total, errorMessages;


CALL apoc.periodic.iterate(
  "CALL apoc.load.csv('https://gist.githubusercontent.com/netj/8836201/raw/6f9306ad21398ea43cba4f7d537619d0e07d5ae3/iris.csv', {header:true}) YIELD map RETURN map",
  "CREATE (i:Iris) 
   SET i.sepalLength = toFloat(map.`sepal.length`), 
       i.sepalWidth = toFloat(map.`sepal.width`), 
       i.petalLength = toFloat(map.`petal.length`), 
       i.petalWidth = toFloat(map.`petal.width`), 
       i.variety = map.variety",
  {batchSize: 100, parallel: true}
)


LOAD CSV WITH HEADERS FROM 'https://gist.githubusercontent.com' AS row
CREATE (i:Iris)
SET i.sepalLength = toFloat(row.`sepal.length`),
    i.sepalWidth = toFloat(row.`sepal.width`),
    i.petalLength = toFloat(row.`petal.length`),
    i.petalWidth = toFloat(row.`petal.width`),
    i.variety = row.variety

Why use APOC instead of standard LOAD CSV?
While Neo4j has a native LOAD CSV command, the APOC Extended version is superior for:
Direct HTTPS/FTP: Better support for various protocols and authentication headers.
Error Handling: Integrated with periodic.iterate for better failure logging.
Flexibility: Easier handling of complex escaping and non-standard delimiters.

docker run -d --name neo4j-gds -p 7474:7474 -p 7687:7687 -e NEO4J_AUTH=neo4j/password -e NEO4J_PLUGINS="[\"apoc\", \"apoc-extended\",\"graph-data-science\"]" -e NEO4J_dbms_security_procedures_unrestricted=gds.*,apoc.* -e NEO4J_dbms_security_procedures_allowlist=gds.*,apoc.* neo4j:latest

GDS
To run an advanced GDS (Graph Data Science) example directly in your **Neo4j Browser**, you can follow this simple 3-step workflow. This example finds the **Shortest Path** between two cities using weights (costs), which is much faster than standard Cypher for large datasets.

### Step 1: Create a Sample Road Network

Run this in your browser to create a set of cities and the "cost" (distance/price) to travel between them.

```cypher
CREATE (a:City {name: 'New York'}),
       (b:City {name: 'Philadelphia'}),
       (c:City {name: 'Washington DC'}),
       (d:City {name: 'Baltimore'}),
       (e:City {name: 'Boston'}),
       (a)-[:ROAD {cost: 95}]->(b),
       (b)-[:ROAD {cost: 100}]->(c),
       (a)-[:ROAD {cost: 215}]->(e),
       (b)-[:ROAD {cost: 40}]->(d),
       (d)-[:ROAD {cost: 40}]->(c);

```

---

### Step 2: Create a Graph Projection

GDS doesn't look at your raw database; it looks at a "snapshot" in memory. We need to "project" our cities and roads into this memory space.

```cypher
CALL gds.graph.project(
  'travelGraph',    // Name of our snapshot
  'City',           // Node label to include
  'ROAD',           // Relationship type to include
  {
    relationshipProperties: 'cost' // Include the 'cost' property for weights
  }
);

```

---

### Step 3: Run the Shortest Path Algorithm

Now we ask GDS to find the cheapest way to get from **New York** to **Washington DC**.

```cypher
MATCH (source:City {name: 'New York'}), (target:City {name: 'Washington DC'})
CALL gds.shortestPath.dijkstra.stream('travelGraph', {
    sourceNode: source,
    targetNode: target,
    relationshipWeightProperty: 'cost'
})
YIELD index, sourceNode, targetNode, totalCost, nodeIds, costs
RETURN [nodeId IN nodeIds | gds.util.asNode(nodeId).name] AS path, totalCost;

```

---

### ðŸ’¡ Why this is better than standard Cypher

If you ran a standard `MATCH p=shortestPath(...)` in Cypher, it would only count the number of "hops" (jumps). GDS's **Dijkstra** algorithm actually looks at the `cost` property on the lines.

* **Cypher Shortest Path:** Might pick NY âž” Boston (1 jump) even if it's expensive.
* **GDS Dijkstra:** Will pick NY âž” Philly âž” Baltimore âž” DC (3 jumps) if the combined cost () is cheaper than the direct flight ().

### ðŸ§¹ Cleanup

When you are done, always remove the projection from memory to keep your Docker container light:

```cypher
CALL gds.graph.drop('travelGraph');


pip install graphdatascience pandas
```
