APOC (**Awesome Procedures On Cypher**) 
### 1. Data Integration (Import/Export)

APOC allows Neo4j to talk to the outside world directly without needing an intermediate Python script.

* **Load JSON/XML/CSV:** Connect to live APIs and turn the response into nodes.
```cypher
CALL apoc.load.json("https://api.example.com/data") YIELD value
MERGE (p:Person {id: value.id}) SET p.name = value.name

```


* **Export to Formats:** Export your graph to JSON, CSV, or even GraphML for Gephi.
```cypher
CALL apoc.export.json.all("all_data.json", {})

```



### 2. Refactoring Tools

Renaming labels or changing relationship types on millions of nodes in standard Cypher is slow and risky. APOC makes it a one-liner.

* **Rename Labels/Types:** ```cypher
CALL apoc.refactor.rename.label("OldLabel", "NewName")
```

```


* **Merge Nodes:** Combine duplicate nodes into one while preserving all relationships.
```cypher
MATCH (n:Person {name: "John"}) 
WITH collect(n) as nodes 
CALL apoc.refactor.mergeNodes(nodes) YIELD node RETURN node

```



### 3. Background Jobs (Periodic)

As we discussed with the "Kill Switch," APOC can run tasks in the background or batch large updates to prevent memory crashes.

* **Iterate in Batches:** Process 1 million updates in chunks of 10,000 to keep the transaction log small.
```cypher
CALL apoc.periodic.iterate(
  "MATCH (u:User) RETURN u",
  "SET u.processed = true",
  {batchSize: 10000, parallel: true}
)

```



### 4. Advanced Path Finding

While GDS handles complex math, APOC provides utility pathfinding for business logic.

* **Dijkstra & A*:** Find paths based on weights (similar to GDS but simpler for small queries).
* **Expanding Paths:** Find all nodes "downstream" regardless of relationship type.
```cypher
MATCH (start:Part {id: 'A1'})
CALL apoc.path.expandConfig(start, {relationshipFilter: "DEPENDS_ON>", minLevel: 1, maxLevel: 5})
YIELD path RETURN path

```



### 5. Virtual Nodes & Relationships

Sometimes you want to show a "summary" graph in the Browser without actually creating data in the database.

* **Virtualize:** You can group 1,000 "Transaction" nodes into one virtual "Summary" relationship for visualization purposes.

---

### Summary Table: APOC vs. GDS

| Feature | APOC | GDS |
| --- | --- | --- |
| **Best For** | Data cleaning, utility tasks, API calls. | Heavy math, PageRank, ML, Clustering. |
| **Memory** | Low (uses standard heap). | High (requires dedicated memory). |
| **Execution** | Runs on live data directly. | Runs on "Projections" in memory. |

---

### üõ†Ô∏è One Final "Power Move"

If you find yourself writing complex `CASE` statements in Cypher, use **`apoc.do.when`**. It allows for true "if-else" logic inside your queries:

```cypher
MATCH (u:User {id: $id})
CALL apoc.do.when(
  u.isVIP,
  'SET u.discount = 0.2 RETURN u',
  'SET u.discount = 0.0 RETURN u',
  {u: u}
) YIELD value
RETURN value.u

```


// 1. Load the XML and use XPath to grab all <book> elements
CALL apoc.load.xml("https://raw.githubusercontent.com/neo4j/apoc/2025.11/core/src/test/resources/xml/books.xml", "/catalog/book") 
YIELD value as book

// 2. Extract values from the map (APOC maps nested tags to a '_children' list)
WITH book.id AS bookId, 
     [item in book._children WHERE item._type = "title"][0]._text AS title,
     [item in book._children WHERE item._type = "author"][0]._text AS author

// 3. Create your nodes
MERGE (b:Book {id: bookId})
SET b.title = title
MERGE (a:Author {name: author})
MERGE (a)-[:WROTE]->(b)